<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Link Validator</title>
    <link rel="stylesheet" href="index.css">
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
</head>
<body>
    <!-- Auth Overlay -->
    <div class="auth-overlay" id="auth-overlay">
        <div class="auth-box">
            <h2>Login Required</h2>
            <input type="email" id="auth-email" placeholder="Email">
            <input type="password" id="auth-password" placeholder="Password">
            <button id="auth-submit">Login</button>
            <div class="auth-error" id="auth-error"></div>
        </div>
    </div>

    <div class="header" id="main-header" style="display: none;">
        <h1>Link Checker ‚úì</h1>
        <input type="file" id="csv-file" accept=".csv,.txt" title="Import companies from CSV">
        <button id="import-csv" class="import-btn">Import CSV to DB</button>
        <input type="text" id="search" placeholder="Search companies...">
        <button id="stats-btn" class="stats-btn">Stats</button>
        <button id="export" class="export-btn">Export CSV</button>
        <button id="logout" class="logout-btn">Logout</button>
        <div class="stats">
            Visited: <span id="clicked-count">0</span> |
            Applied: <span id="applied-count">0</span> |
            Total: <span id="total-count" class="valid-count">0</span>
            <span id="sync-status" class="sync-status"></span>
        </div>
        <div class="filters">
            <button data-filter="all" class="active">All</button>
            <button data-filter="unvisited">Unvisited</button>
            <button data-filter="clicked">Visited</button>
            <button data-filter="applied">Applied (All)</button>
            <button data-filter="interviewing">Interviewing</button>
            <button data-filter="rejected">Rejected</button>
            <button data-filter="failed-interview">Failed Interview</button>
            <button data-filter="skipped">Skipped</button>
            <button data-filter="not-qualified">Not Qualified</button>
            <button data-filter="no-jobs">No Jobs</button>
            <button data-filter="not-relevant">Not Relevant</button>
            <button data-filter="not-in-us">Not in US</button>
        </div>
    </div>

    <div class="grid" id="grid" style="display: none;">
        <div class="loading">Connecting to database...</div>
    </div>

    <!-- Stats Modal -->
    <div class="stats-modal" id="stats-modal">
        <div class="stats-modal-content">
            <div class="stats-modal-header">
                <h2>Application Stats</h2>
                <button class="stats-modal-close" id="stats-modal-close">‚úï</button>
            </div>
            <div class="stats-summary" id="stats-summary"></div>
            <div class="chart-container">
                <div class="chart-title">Applications by Day</div>
                <div id="stats-chart"></div>
            </div>
            <button class="llm-prompt-btn" id="llm-prompt-btn">Generate LLM Analysis Prompt</button>
        </div>
    </div>

    <!-- LLM Prompt Modal -->
    <div class="prompt-modal" id="prompt-modal">
        <div class="prompt-modal-content">
            <div class="prompt-modal-header">
                <h2>LLM Analysis Prompt</h2>
                <button class="prompt-modal-close" id="prompt-modal-close">‚úï</button>
            </div>
            <textarea id="prompt-text" readonly></textarea>
            <div class="prompt-actions">
                <button id="copy-prompt-btn">Copy to Clipboard</button>
            </div>
        </div>
    </div>

    <!-- Notes Popup -->
    <div class="notes-popup" id="notes-popup">
        <textarea id="notes-textarea" placeholder="Add a note..."></textarea>
        <div class="notes-popup-btns">
            <button class="cancel-btn" id="notes-cancel">Cancel</button>
            <button id="notes-save">Save</button>
        </div>
    </div>

    <script>
        // ============================================
        // SUPABASE CONFIGURATION
        // Replace these with your Supabase project credentials
        // ============================================
        const SUPABASE_URL = 'https://ampsliudevabkybsbqil.supabase.co';
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImFtcHNsaXVkZXZhYmt5YnNicWlsIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjYzMjE4MTIsImV4cCI6MjA4MTg5NzgxMn0.iZFMR_NheMnFajb_TiW-Gy2dXHgsLpmIgpgJV20RCiM';

        // Initialize Supabase client
        const { createClient } = supabase;
        const db = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

        // ============================================
        // AUTHENTICATION
        // ============================================
        const authOverlay = document.getElementById('auth-overlay');
        const authEmail = document.getElementById('auth-email');
        const authPassword = document.getElementById('auth-password');
        const authSubmit = document.getElementById('auth-submit');
        const authError = document.getElementById('auth-error');
        const mainHeader = document.getElementById('main-header');
        const logoutBtn = document.getElementById('logout');

        let appInitialized = false;
        function showApp() {
            authOverlay.style.display = 'none';
            mainHeader.style.display = 'flex';
            document.getElementById('grid').style.display = 'grid';
            if (!appInitialized) {
                appInitialized = true;
                init(); // Initialize the app after login
            }
        }

        function showLogin() {
            authOverlay.style.display = 'flex';
            mainHeader.style.display = 'none';
            document.getElementById('grid').style.display = 'none';
        }

        // Check for existing session on load
        db.auth.getSession().then(({ data: { session } }) => {
            if (session) {
                showApp();
            } else {
                showLogin();
            }
        });

        // Listen for auth changes
        db.auth.onAuthStateChange((event, session) => {
            if (session) {
                showApp();
            } else {
                showLogin();
            }
        });

        // Login handler
        authSubmit.addEventListener('click', async () => {
            authError.textContent = '';
            const email = authEmail.value.trim();
            const password = authPassword.value;

            if (!email || !password) {
                authError.textContent = 'Please enter email and password';
                return;
            }

            const { error } = await db.auth.signInWithPassword({ email, password });
            if (error) {
                authError.textContent = error.message;
            }
        });

        // Enter key to submit
        authPassword.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') authSubmit.click();
        });

        // Logout handler
        logoutBtn.addEventListener('click', async () => {
            await db.auth.signOut();
        });

        // ============================================
        // DOM ELEMENTS
        // ============================================
        const csvFile       = document.getElementById('csv-file');
        const importBtn     = document.getElementById('import-csv');
        const exportBtn     = document.getElementById('export');
        const searchInput   = document.getElementById('search');
        const grid          = document.getElementById('grid');
        const clickedCount  = document.getElementById('clicked-count');
        const appliedCount  = document.getElementById('applied-count');
        const totalCount    = document.getElementById('total-count');
        const syncStatus    = document.getElementById('sync-status');
        const filterBtns    = document.querySelectorAll('.filters button');
        const statsBtn      = document.getElementById('stats-btn');
        const statsModal    = document.getElementById('stats-modal');
        const statsModalClose = document.getElementById('stats-modal-close');
        const statsSummary  = document.getElementById('stats-summary');
        const statsChart    = document.getElementById('stats-chart');
        const notesPopup    = document.getElementById('notes-popup');
        const notesTextarea = document.getElementById('notes-textarea');
        const notesSave     = document.getElementById('notes-save');
        const notesCancel   = document.getElementById('notes-cancel');
        const llmPromptBtn  = document.getElementById('llm-prompt-btn');
        const promptModal   = document.getElementById('prompt-modal');
        const promptModalClose = document.getElementById('prompt-modal-close');
        const promptText    = document.getElementById('prompt-text');
        const copyPromptBtn = document.getElementById('copy-prompt-btn');

        // ============================================
        // STATE
        // ============================================
        let companyData         = [];   // Array of company objects from Supabase
        let currentFilter       = 'all';
        let clicked             = new Set();
        let statuses            = {};
        let notes               = {};
        let currentContextLink  = null;
        let currentNoteSlug     = null;

        const allStatuses = [
            'applied-ashby', 'applied-linkedin', 'applied-yc', 'applied-email', 'applied-website',
            'applied-lever', 'applied-gem', 'applied-greenhouse',
            'interviewing', 'rejected', 'failed-interview', 'skipped', 'not-qualified', 'no-jobs', 'not-relevant', 'not-in-us'
        ];

        // ============================================
        // CONTEXT MENU
        // ============================================
        const contextMenu = document.createElement('div');
        contextMenu.className = 'context-menu';
        contextMenu.style.display = 'none';
        contextMenu.innerHTML = `
            <div data-status="applied-ashby"     >‚úì Applied - Ashby</div>
            <div data-status="applied-linkedin"  >‚úì Applied - LinkedIn</div>
            <div data-status="applied-yc"        >‚úì Applied - YC</div>
            <div data-status="applied-email"     >‚úì Applied - Email</div>
            <div data-status="applied-website"   >‚úì Applied - Website</div>
            <div data-status="applied-lever"     >‚úì Applied - Lever</div>
            <div data-status="applied-gem"       >‚úì Applied - Gem</div>
            <div data-status="applied-greenhouse">‚úì Applied - Greenhouse</div>
            <div data-status="interviewing"      >Interviewing</div>
            <div data-status="rejected"          >X Rejected</div>
            <div data-status="failed-interview"  >X Failed Interview</div>
            <div data-status="skipped"           >‚Äî Skipped</div>
            <div data-status="not-qualified"     >‚úó Not Qualified</div>
            <div data-status="no-jobs"           >‚Äî No Jobs</div>
            <div data-status="not-relevant"      >‚Äî Not Relevant</div>
            <div data-status="not-in-us"         >üåç Not in US</div>
            <div class="clear-status" data-status="clear">Clear Status</div>
            <div data-action="note" style="border-top: 1px solid #444; margin-top: 6px; padding-top: 12px;">Add Note</div>
            <div class="close-menu" data-status="close">‚úï Close</div>
        `;
        document.body.appendChild(contextMenu);

        document.addEventListener('click', () => contextMenu.style.display = 'none');
        document.addEventListener('keydown', (e) => { if (e.key === 'Escape') contextMenu.style.display = 'none'; });

        // ============================================
        // SUPABASE DATABASE FUNCTIONS
        // ============================================

        function setSyncStatus(message, type = '') {
            syncStatus.textContent = message;
            syncStatus.className = 'sync-status ' + type;
            if (type === 'success') {
                setTimeout(() => { syncStatus.textContent = ''; }, 2000);
            }
        }

        async function loadCompanies() {
            setSyncStatus('Loading...', 'syncing');

            // Supabase defaults to 1000 rows, need to paginate to get all
            let allData = [];
            let from = 0;
            const pageSize = 1000;

            while (true) {
                const { data, error } = await db
                    .from('companies')
                    .select('*')
                    .eq('link_status', 'active')
                    .order('name')
                    .range(from, from + pageSize - 1);

                if (error) {
                    console.error('Load error:', error);
                    setSyncStatus('Load failed', 'error');
                    return [];
                }

                allData = allData.concat(data);

                if (data.length < pageSize) break; // Last page
                from += pageSize;
            }

            setSyncStatus('Loaded', 'success');
            return allData;
        }

        async function saveStatus(slug, status, visited = true) {
            setSyncStatus('Saving...', 'syncing');
            const updates = { status, visited };
            if (status.startsWith('applied-')) {
                updates.applied_at = new Date().toISOString();
            }
            const { error } = await db
                .from('companies')
                .update(updates)
                .eq('slug', slug);

            if (error) {
                console.error('Save error:', error);
                setSyncStatus('Save failed', 'error');
                return false;
            }
            setSyncStatus('Saved', 'success');
            return true;
        }

        async function markVisited(slug) {
            setSyncStatus('Saving...', 'syncing');
            const { error } = await db
                .from('companies')
                .update({ visited: true })
                .eq('slug', slug);

            if (error) {
                console.error('Visit error:', error);
                setSyncStatus('Save failed', 'error');
                return false;
            }
            setSyncStatus('Saved', 'success');
            return true;
        }

        async function clearAllStatuses() {
            setSyncStatus('Clearing...', 'syncing');
            const { error } = await db
                .from('companies')
                .update({ status: 'unvisited', visited: false });

            if (error) {
                console.error('Clear error:', error);
                setSyncStatus('Clear failed', 'error');
                return false;
            }
            setSyncStatus('Cleared', 'success');
            return true;
        }

        async function saveNote(slug, note) {
            setSyncStatus('Saving...', 'syncing');
            const { error } = await db
                .from('companies')
                .update({ notes: note })
                .eq('slug', slug);

            if (error) {
                console.error('Note error:', error);
                setSyncStatus('Save failed', 'error');
                return false;
            }
            setSyncStatus('Saved', 'success');
            return true;
        }

        async function importCompaniesToDB(companies) {
            setSyncStatus('Importing...', 'syncing');

            // Upsert companies (insert or update if slug exists)
            const { error } = await db
                .from('companies')
                .upsert(
                    companies.map(c => ({
                        slug: c.slug,
                        name: c.name,
                        url: c.url,
                        status: 'unvisited',
                        visited: false,
                        link_status: 'unchecked'  // Needs validation before showing
                    })),
                    { onConflict: 'slug', ignoreDuplicates: false }
                );

            if (error) {
                console.error('Import error:', error);
                setSyncStatus('Import failed', 'error');
                return false;
            }
            setSyncStatus(`Imported ${companies.length} companies`, 'success');
            return true;
        }

        async function checkUrl(url) {
            try {
                const response = await fetch(url);
                if (!response.ok) return 'dead';
                const text = await response.text();
                // Only reject if Ashby explicitly says no org/jobBoard
                const noPage = text.includes('"organization":null') || text.includes('"jobBoard":null');
                return noPage ? 'dead' : 'active';
            } catch {
                return 'dead';
            }
        }

        async function validateUnchecked(onProgress) {
            const { data: companies, error } = await db
                .from('companies')
                .select('id, name, slug, url')
                .eq('link_status', 'unchecked')
                .order('name');

            if (error || !companies || companies.length === 0) {
                return { active: 0, dead: 0 };
            }

            let activeCount = 0;
            let deadCount = 0;

            // Process in batches of 5
            for (let i = 0; i < companies.length; i += 5) {
                const batch = companies.slice(i, i + 5);

                const results = await Promise.all(
                    batch.map(async (company) => {
                        const linkStatus = await checkUrl(company.url);
                        return { ...company, linkStatus };
                    })
                );

                for (const result of results) {
                    await db
                        .from('companies')
                        .update({ link_status: result.linkStatus })
                        .eq('id', result.id);

                    if (result.linkStatus === 'active') activeCount++;
                    else deadCount++;
                }

                if (onProgress) {
                    onProgress(Math.min(i + 5, companies.length), companies.length, activeCount, deadCount);
                }

                // Small delay for rate limiting
                await new Promise(r => setTimeout(r, 100));
            }

            return { active: activeCount, dead: deadCount };
        }

        // ============================================
        // MIGRATION FROM LOCALSTORAGE
        // ============================================

        async function migrateFromLocalStorage() {
            const migrated = localStorage.getItem('supabase-migrated');
            if (migrated) return;

            const oldClicked = JSON.parse(localStorage.getItem('ashby-clicked-v2') || '[]');
            const oldStatuses = JSON.parse(localStorage.getItem('ashby-statuses-v2') || '{}');

            if (oldClicked.length === 0 && Object.keys(oldStatuses).length === 0) {
                localStorage.setItem('supabase-migrated', 'true');
                return;
            }

            setSyncStatus('Migrating data...', 'syncing');

            let migrationErrors = 0;
            for (const slug of oldClicked) {
                const status = oldStatuses[slug] || 'unvisited';
                const { error } = await db
                    .from('companies')
                    .update({ visited: true, status: status !== 'unvisited' ? status : 'unvisited' })
                    .eq('slug', slug);
                if (error) migrationErrors++;
            }

            // Also migrate statuses for companies not in clicked set
            for (const [slug, status] of Object.entries(oldStatuses)) {
                if (!oldClicked.includes(slug)) {
                    const { error } = await db
                        .from('companies')
                        .update({ status, visited: true })
                        .eq('slug', slug);
                    if (error) migrationErrors++;
                }
            }

            if (migrationErrors === 0) {
                localStorage.setItem('supabase-migrated', 'true');
                setSyncStatus('Migration complete', 'success');
                console.log('Migration from localStorage complete');
            } else {
                setSyncStatus(`Migration had ${migrationErrors} errors`, 'error');
            }
        }

        // ============================================
        // CSV PARSING
        // ============================================

        function formatCompanyName(name) {
            return name.trim().toLowerCase().replace(/[^a-z0-9\s-]/g, '').replace(/\s+/g, '').replace(/-+/g, '');
        }

        function parseCSV(text) {
            const lines = text.split('\n');
            const companies = [];

            const startIndex = lines[0]?.toLowerCase().includes('company') ? 1 : 0;

            for (let i = startIndex; i < lines.length; i++) {
                const line = lines[i];
                if (!line.trim()) continue;

                const match = line.match(/^"([^"]+)"/);
                let name;
                if (match) {
                    name = match[1];
                } else {
                    const cells = line.split(/[,\t]/);
                    name = cells[0]?.trim().replace(/^["']|["']$/g, '');
                }

                if (name && name.length > 1) {
                    const slug = formatCompanyName(name);
                    companies.push({
                        name: name,
                        slug: slug,
                        url: `https://jobs.ashbyhq.com/${slug}`
                    });
                }
            }

            // Remove duplicates by slug
            const seen = new Set();
            return companies.filter(c => {
                if (seen.has(c.slug)) return false;
                seen.add(c.slug);
                return true;
            });
        }

        // ============================================
        // UI FUNCTIONS
        // ============================================

        function updateStats() {
            clickedCount.textContent = clicked.size;
            appliedCount.textContent = Object.values(statuses).filter(s => s.startsWith('applied')).length;
        }

        function applyFilters() {
            const query = searchInput.value.toLowerCase().trim();
            const links = grid.querySelectorAll('a');

            links.forEach(link => {
                const name = link.textContent.toLowerCase();
                const formatted = link.dataset.formatted;
                const status = statuses[formatted] || (clicked.has(formatted) ? 'clicked' : 'unvisited');

                let matchesFilter = currentFilter === 'all' ||
                    (currentFilter === 'applied' ? status.startsWith('applied') : status === currentFilter);
                let matchesSearch = query === '' || name.includes(query);

                link.style.display = (matchesFilter && matchesSearch) ? 'block' : 'none';
            });
        }

        function generateGrid() {
            if (companyData.length === 0) {
                grid.innerHTML = '<div class="empty">No companies in database. Import a CSV to get started.</div>';
                totalCount.textContent = '0';
                return;
            }

            grid.innerHTML = '';
            totalCount.textContent = companyData.length;

            companyData.forEach(company => {
                const link = document.createElement('a');
                link.href = company.url;
                link.target = '_blank';
                link.dataset.formatted = company.slug;

                const nameSpan = document.createElement('span');
                nameSpan.className = 'company-name';
                nameSpan.textContent = company.name;
                link.appendChild(nameSpan);

                if (company.applied_at) {
                    const dateSpan = document.createElement('span');
                    dateSpan.className = 'applied-date';
                    dateSpan.textContent = new Date(company.applied_at).toLocaleDateString();
                    link.appendChild(dateSpan);
                }

                if (company.notes) {
                    const noteIndicator = document.createElement('span');
                    noteIndicator.className = 'note-indicator';
                    link.appendChild(noteIndicator);
                    link.title = company.notes;
                    notes[company.slug] = company.notes;
                }

                if (company.visited) {
                    link.classList.add('clicked');
                    clicked.add(company.slug);
                }
                if (company.status && company.status !== 'unvisited') {
                    link.classList.remove('clicked');
                    link.classList.add(company.status);
                    statuses[company.slug] = company.status;
                }

                link.addEventListener('click', async function(e) {
                    e.preventDefault();
                    window.open(company.url, '_blank', 'noopener');
                    if (!statuses[company.slug]) {
                        this.classList.add('clicked');
                        clicked.add(company.slug);
                        updateStats();
                        await markVisited(company.slug);
                    }
                });

                link.addEventListener('contextmenu', function(e) {
                    e.preventDefault();
                    currentContextLink = this;
                    contextMenu.style.display = 'block';
                    const x = Math.min(e.clientX, window.innerWidth - contextMenu.offsetWidth - 10);
                    const y = Math.min(e.clientY, window.innerHeight - contextMenu.offsetHeight - 10);
                    contextMenu.style.left = x + 'px';
                    contextMenu.style.top = y + 'px';
                });

                grid.appendChild(link);
            });

            updateStats();
            applyFilters();
        }

        // ============================================
        // EVENT HANDLERS
        // ============================================

        filterBtns.forEach(btn => {
            btn.addEventListener('click', function() {
                filterBtns.forEach(b => b.classList.remove('active'));
                this.classList.add('active');
                currentFilter = this.dataset.filter;
                applyFilters();
            });
        });

        contextMenu.addEventListener('click', async function(e) {
            const action = e.target.dataset.action;
            if (action === 'note' && currentContextLink) {
                e.stopPropagation();
                const slug = currentContextLink.dataset.formatted;
                currentNoteSlug = slug;
                notesTextarea.value = notes[slug] || '';
                notesPopup.style.display = 'block';
                const rect = currentContextLink.getBoundingClientRect();
                notesPopup.style.left = Math.min(rect.left, window.innerWidth - 300) + 'px';
                notesPopup.style.top = Math.min(rect.bottom + 5, window.innerHeight - 150) + 'px';
                notesTextarea.focus();
                contextMenu.style.display = 'none';
                return;
            }

            const status = e.target.dataset.status;
            if (!status || !currentContextLink) return;
            if (status === 'close') { contextMenu.style.display = 'none'; return; }

            const formatted = currentContextLink.dataset.formatted;
            allStatuses.forEach(s => currentContextLink.classList.remove(s));
            currentContextLink.classList.remove('clicked');

            if (status === 'clear') {
                delete statuses[formatted];
                clicked.delete(formatted);
                // Remove any existing date span
                const existingDate = currentContextLink.querySelector('.applied-date');
                if (existingDate) existingDate.remove();
                await saveStatus(formatted, 'unvisited', false);
            } else {
                statuses[formatted] = status;
                currentContextLink.classList.add(status);
                clicked.add(formatted);
                // Add or update date span for applied statuses
                if (status.startsWith('applied-')) {
                    let dateSpan = currentContextLink.querySelector('.applied-date');
                    if (!dateSpan) {
                        dateSpan = document.createElement('span');
                        dateSpan.className = 'applied-date';
                        currentContextLink.appendChild(dateSpan);
                    }
                    dateSpan.textContent = new Date().toLocaleDateString();
                }
                await saveStatus(formatted, status, true);
            }

            updateStats();
            applyFilters();
            contextMenu.style.display = 'none';
        });

        searchInput.addEventListener('input', applyFilters);

        let pendingCSVData = null;
        csvFile.addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = function(e) {
                pendingCSVData = parseCSV(e.target.result);
                importBtn.textContent = `Import ${pendingCSVData.length} Companies`;
            };
            reader.readAsText(file);
        });

        importBtn.addEventListener('click', async function() {
            if (!pendingCSVData || pendingCSVData.length === 0) {
                alert('Please select a CSV file first');
                return;
            }

            this.disabled = true;
            this.textContent = 'Importing...';

            const success = await importCompaniesToDB(pendingCSVData);

            if (success) {
                // Validate the newly imported companies
                this.textContent = 'Validating URLs...';
                setSyncStatus('Validating...', 'syncing');

                const { active, dead } = await validateUnchecked((current, total, activeCount, deadCount) => {
                    this.textContent = `Validating ${current}/${total}...`;
                    setSyncStatus(`‚úì ${activeCount} active, ‚úó ${deadCount} dead`, 'syncing');
                });

                setSyncStatus(`Done! ${active} active, ${dead} dead`, 'success');

                // Reload data from database
                companyData = await loadCompanies();
                clicked.clear();
                statuses = {};
                generateGrid();
                pendingCSVData = null;
                csvFile.value = '';
            }

            this.disabled = false;
            this.textContent = 'Import CSV to DB';
        });

        exportBtn.addEventListener('click', function() {
            const links = grid.querySelectorAll('a');
            if (links.length === 0) { alert('No companies to export'); return; }

            const statusLabels = {
                'applied-ashby': 'Applied - Ashby',
                'applied-linkedin': 'Applied - LinkedIn',
                'applied-yc': 'Applied - YC',
                'applied-email': 'Applied - Email',
                'applied-website': 'Applied - Website',
                'applied-lever': 'Applied - Lever',
                'applied-gem': 'Applied - Gem',
                'interviewing': 'Interviewing',
                'rejected': 'Rejected',
                'failed-interview': 'Failed Interview',
                'skipped': 'Skipped',
                'not-qualified': 'Not Qualified',
                'no-jobs': 'No Jobs',
                'not-relevant': 'Not Relevant',
                'not-in-us': 'Not in US'
            };

            let csv = 'Company,Ashby URL,Status\n';
            links.forEach(link => {
                const name = link.textContent.replace(/[‚úì‚úó‚òÖ‚Äî].*$/, '').trim();
                const formatted = link.dataset.formatted;
                let status = statuses[formatted] ? (statusLabels[statuses[formatted]] || statuses[formatted]) : (clicked.has(formatted) ? 'Visited' : 'Not Visited');
                csv += `"${name}","${link.href}","${status}"\n`;
            });

            const blob = new Blob([csv], { type: 'text/csv' });
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = 'ashby-tracker-' + new Date().toISOString().split('T')[0] + '.csv';
            a.click();
        });

        // ============================================
        // STATS MODAL
        // ============================================

        function renderStats() {
            // Calculate summary stats
            const applied = companyData.filter(c => c.status?.startsWith('applied-'));
            const interviewing = companyData.filter(c => c.status === 'interviewing');
            const rejected = companyData.filter(c => c.status === 'rejected' || c.status === 'failed-interview');

            const responseCount = interviewing.length + rejected.length;
            const responseRate = applied.length > 0 ? Math.round((responseCount / applied.length) * 100) : 0;

            statsSummary.innerHTML = `
                <div class="stats-summary-item">
                    <div class="number">${applied.length}</div>
                    <div class="label">Applied</div>
                </div>
                <div class="stats-summary-item">
                    <div class="number">${interviewing.length}</div>
                    <div class="label">Interviewing</div>
                </div>
                <div class="stats-summary-item">
                    <div class="number">${rejected.length}</div>
                    <div class="label">Rejected</div>
                </div>
                <div class="stats-summary-item">
                    <div class="number">${responseRate}%</div>
                    <div class="label">Response Rate</div>
                </div>
            `;

            // Group applications by day
            const byDay = {};
            applied.forEach(c => {
                if (c.applied_at) {
                    const day = new Date(c.applied_at).toLocaleDateString();
                    byDay[day] = (byDay[day] || 0) + 1;
                }
            });

            // Sort by date and get last 14 days max
            const sortedDays = Object.entries(byDay)
                .sort((a, b) => new Date(a[0]) - new Date(b[0]))
                .slice(-14);

            if (sortedDays.length === 0) {
                statsChart.innerHTML = '<div style="color: #666; text-align: center; padding: 20px;">No application dates recorded yet</div>';
                return;
            }

            const maxCount = Math.max(...sortedDays.map(d => d[1]));

            statsChart.innerHTML = sortedDays.map(([day, count]) => {
                const pct = (count / maxCount) * 100;
                const shortDay = new Date(day).toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
                return `
                    <div class="chart-bar-row">
                        <div class="chart-bar-label">${shortDay}</div>
                        <div class="chart-bar-track">
                            <div class="chart-bar-fill" style="width: ${pct}%">${count}</div>
                        </div>
                    </div>
                `;
            }).join('');
        }

        statsBtn.addEventListener('click', () => {
            renderStats();
            statsModal.classList.add('open');
        });

        statsModalClose.addEventListener('click', () => {
            statsModal.classList.remove('open');
        });

        statsModal.addEventListener('click', (e) => {
            if (e.target === statsModal) statsModal.classList.remove('open');
        });

        // ============================================
        // LLM PROMPT GENERATOR
        // ============================================

        function generateLLMPrompt() {
            const now = Date.now();
            const ghostedThreshold = 14 * 24 * 60 * 60 * 1000; // 14 days

            // Calculate all stats
            const applied = companyData.filter(c => c.status?.startsWith('applied-'));
            const interviewing = companyData.filter(c => c.status === 'interviewing');
            const rejected = companyData.filter(c => c.status === 'rejected');
            const failedInterview = companyData.filter(c => c.status === 'failed-interview');
            const skipped = companyData.filter(c => c.status === 'skipped');

            // Breakdown by application method
            const byMethod = {
                ashby: applied.filter(c => c.status === 'applied-ashby').length,
                linkedin: applied.filter(c => c.status === 'applied-linkedin').length,
                yc: applied.filter(c => c.status === 'applied-yc').length,
                email: applied.filter(c => c.status === 'applied-email').length,
                website: applied.filter(c => c.status === 'applied-website').length,
                lever: applied.filter(c => c.status === 'applied-lever').length,
                gem: applied.filter(c => c.status === 'applied-gem').length,
            };

            // Calculate ghosted (applied > 14 days ago, still in applied-* status)
            const ghosted = applied.filter(c => {
                if (!c.applied_at) return false;
                const appliedTime = new Date(c.applied_at).getTime();
                const daysSince = now - appliedTime;
                return daysSince > ghostedThreshold;
            });

            // Response stats (skipped doesn't count - that's you passing on them)
            const responseCount = interviewing.length + rejected.length + failedInterview.length;
            const responseRate = applied.length > 0 ? Math.round((responseCount / applied.length) * 100) : 0;

            // Date range
            const appliedDates = applied
                .filter(c => c.applied_at)
                .map(c => new Date(c.applied_at))
                .sort((a, b) => a - b);

            const startDate = appliedDates[0];
            const endDate = appliedDates[appliedDates.length - 1];
            const weeksSince = startDate ? Math.ceil((now - startDate.getTime()) / (7 * 24 * 60 * 60 * 1000)) : 0;
            const appsPerWeek = weeksSince > 0 ? Math.round(applied.length / weeksSince) : applied.length;

            // Collect notes/feedback
            const companiesWithNotes = companyData.filter(c => c.notes && c.notes.trim());

            // Format date helper
            const formatDate = (date) => date ? date.toLocaleDateString('en-US', { month: 'long', day: 'numeric', year: 'numeric' }) : 'N/A';

            // Build the prompt
            let prompt = `# Job Search Analysis Request

            ## About Me
            I'm Anthony, a full-stack engineer with ~2 years experience, currently running EL3 Tech (consulting). I built Rangley, an iOS social app for finding tennis partners, solo in about two months from backend to App Store (40 active users). Currently building Mr. Fox, a React Native marketplace with Stripe Connect. My stack: TypeScript, React, React Native, Node.js, PostgreSQL, Swift, Python, AWS.

            **Target:** Founding engineer roles at early-stage startups (YC preferred), small teams, high ownership. Relocating from Chicago to SF (NYC acceptable).

            **Avoiding:** Senior-level positions, infra/DevOps-heavy roles, FDE positions, security clearance required.

            ---

            ## Raw Data Export (${new Date().toLocaleDateString('en-US', { month: 'long', day: 'numeric', year: 'numeric' })})

            ### Timeline
            - Search started: ${formatDate(startDate)}
            - Days active: ${daysSinceStart}
            - Most recent app: ${formatDate(endDate)}

            ### Application Volume
            | Metric | Value |
            |--------|-------|
            | Total applications | ${applied.length} |
            | Apps/day average | ${appsPerDay} |
            | Apps/week average | ${appsPerWeek} |
            | Last 7 days | ${recentApps.length} |

            ### Funnel Metrics
            | Stage | Count | Rate |
            |-------|-------|------|
            | Applied | ${applied.length} | 100% |
            | Any response | ${totalResponses} | ${responseRate}% |
            | Got interview | ${interviewing.length + failedInterview.length} | ${interviewConversionRate}% |
            | Passed interview | ${interviewing.length} | ${interviewPassRate}% of interviews |
            | Failed interview | ${failedInterview.length} | ${formatPct(failedInterview.length, interviewing.length + failedInterview.length)} of interviews |
            | Rejected (no interview) | ${rejected.length} | ${formatPct(rejected.length, applied.length)} |
            | Ghosted (14+ days) | ${ghosted.length} | ${formatPct(ghosted.length, applied.length)} |
            | Still pending | ${pending.length} | ${formatPct(pending.length, applied.length)} |

            ### Application Method Breakdown
            | Method | Count | % of Total |
            |--------|-------|------------|
            ${Object.entries(methodStats).map(([key, val]) => 
            `| ${val.label} | ${val.applied.length} | ${formatPct(val.applied.length, applied.length)} |`
            ).join('\n')}

            ### Self-Filtered (I passed on these)
            | Reason | Count |
            |--------|-------|
            | Skipped (not interested) | ${skipped.length} |
            | Not qualified | ${notQualified.length} |
            | No jobs posted | ${noJobs.length} |
            | Not relevant | ${notRelevant.length} |
            | Not in US | ${notInUS.length} |
            | **Total filtered** | ${skipped.length + notQualified.length + noJobs.length + notRelevant.length + notInUS.length} |

            ### Activity by Day of Week
            ${dayNames.map((day, i) => `- ${day}: ${byDayOfWeek[i]} apps`).join('\n')}
            - Most active: ${dayNames[maxDayIdx]} (${byDayOfWeek[maxDayIdx]})
            - Least active: ${dayNames[minDayIdx]} (${byDayOfWeek[minDayIdx]})
            `;

            // Add rejection feedback
            if (rejectionNotes.length > 0) {
                prompt += `\n### Rejection Feedback Received\n`;
                rejectionNotes.forEach(c => {
                    const stage = c.status === 'failed-interview' ? 'post-interview' : 'initial screen';
                    prompt += `- **${c.name}** (${stage}): "${c.notes}"\n`;
                });
            }

            // Add interview notes
            if (interviewNotes.length > 0) {
                prompt += `\n### Active Interview Notes\n`;
                interviewNotes.forEach(c => {
                    prompt += `- **${c.name}**: "${c.notes}"\n`;
                });
            }

            // Add other notes
            if (otherNotes.length > 0) {
                prompt += `\n### Other Notes\n`;
                otherNotes.forEach(c => {
                    const statusLabel = c.status ? c.status.replace(/-/g, ' ') : 'unknown';
                    prompt += `- **${c.name}** (${statusLabel}): "${c.notes}"\n`;
                });
            }

            // Calculated insights section
            prompt += `\n---

            ## Pre-Calculated Insights

            ### Conversion Analysis
            - **Top of funnel ‚Üí Response:** ${responseRate}% (${totalResponses}/${applied.length})
            - **Response ‚Üí Interview:** ${totalResponses > 0 ? formatPct(interviewing.length + failedInterview.length, totalResponses) : 'N/A'} (${interviewing.length + failedInterview.length}/${totalResponses})
            - **Interview ‚Üí Advancing:** ${interviewPassRate}% (${interviewing.length}/${interviewing.length + failedInterview.length})

            ### Red Flags to Investigate
            ${ghosted.length > applied.length * 0.5 ? `- ‚ö†Ô∏è High ghost rate (${formatPct(ghosted.length, applied.length)}) - may indicate resume/application issues\n` : ''}${rejected.length > totalResponses * 0.7 ? `- ‚ö†Ô∏è Most responses are rejections without interviews - profile may not match target roles\n` : ''}${failedInterview.length > interviewing.length ? `- ‚ö†Ô∏è Failing more interviews than passing - interview prep needed\n` : ''}${recentApps.length < 5 ? `- ‚ö†Ô∏è Low recent activity (${recentApps.length} apps in last 7 days) - velocity dropping\n` : ''}${applied.length > 50 && totalResponses < 5 ? `- ‚ö†Ô∏è Very low response rate despite volume - fundamental positioning issue likely\n` : ''}${Object.values(methodStats).filter(m => m.applied.length > 0).length === 1 ? `- ‚ö†Ô∏è Only using one application channel - diversify\n` : ''}

            ### Potential Bright Spots
            ${responseRate > 10 ? `- ‚úì Response rate above 10% is decent for cold applications\n` : ''}${interviewing.length > 0 ? `- ‚úì Active interviews in pipeline (${interviewing.length})\n` : ''}${interviewPassRate > 50 ? `- ‚úì Passing most interviews - keep doing what you're doing there\n` : ''}${appsPerWeek > 20 ? `- ‚úì Good application velocity (${appsPerWeek}/week)\n` : ''}

            ---

            ## What I Need From You

            Analyze this data and give me:

            1. **Diagnosis:** Where is my funnel breaking? Be specific about which stage and why you think that's happening.

            2. **Method Analysis:** Which application channels seem to be working/not working? Should I double down or diversify?

            3. **Velocity Check:** Am I applying enough? Too much (spray and pray)? What's the right balance?

            4. **Pattern Recognition:** Any patterns in the rejection feedback or timing that I should know about?

            5. **Next 7 Days:** Give me 3 specific, actionable things to do this week. Not generic advice - specific to my numbers.

            6. **Honest Assessment:** Given my profile (2 years exp, shipped iOS app, consulting background, targeting founding engineer at early-stage startups in SF), are my expectations realistic? What should I adjust?

            Be direct. Reference my actual numbers. Skip the motivational fluff unless you have something specific to say.`;
                        return prompt;
        }

        async function copyToClipboard(text) {
            try {
                await navigator.clipboard.writeText(text);
                return true;
            } catch (err) {
                console.error('Copy failed:', err);
                return false;
            }
        }

        llmPromptBtn.addEventListener('click', () => {
            const prompt = generateLLMPrompt();
            promptText.value = prompt;
            statsModal.classList.remove('open');
            promptModal.classList.add('open');
        });

        promptModalClose.addEventListener('click', () => {
            promptModal.classList.remove('open');
        });

        promptModal.addEventListener('click', (e) => {
            if (e.target === promptModal) promptModal.classList.remove('open');
        });

        copyPromptBtn.addEventListener('click', async () => {
            const success = await copyToClipboard(promptText.value);
            if (success) {
                copyPromptBtn.textContent = 'Copied!';
                copyPromptBtn.classList.add('copied');
                setTimeout(() => {
                    copyPromptBtn.textContent = 'Copy to Clipboard';
                    copyPromptBtn.classList.remove('copied');
                }, 2000);
            }
        });

        // ============================================
        // NOTES POPUP
        // ============================================

        notesCancel.addEventListener('click', () => {
            notesPopup.style.display = 'none';
            currentNoteSlug = null;
        });

        notesSave.addEventListener('click', async () => {
            if (!currentNoteSlug) return;
            const note = notesTextarea.value.trim();
            const success = await saveNote(currentNoteSlug, note);

            if (success) {
                notes[currentNoteSlug] = note;
                // Update or add/remove indicator
                const link = document.querySelector(`a[data-formatted="${currentNoteSlug}"]`);
                if (link) {
                    let indicator = link.querySelector('.note-indicator');
                    if (note) {
                        if (!indicator) {
                            indicator = document.createElement('span');
                            indicator.className = 'note-indicator';
                            link.appendChild(indicator);
                        }
                        link.title = note;
                    } else {
                        if (indicator) indicator.remove();
                        link.title = '';
                    }
                }
            }

            notesPopup.style.display = 'none';
            currentNoteSlug = null;
        });

        document.addEventListener('click', (e) => {
            if (!notesPopup.contains(e.target) && notesPopup.style.display === 'block') {
                notesPopup.style.display = 'none';
                currentNoteSlug = null;
            }
        });

        // ============================================
        // INITIALIZATION
        // ============================================

        async function init() {
            // Check if Supabase is configured
            if (SUPABASE_URL === 'YOUR_SUPABASE_URL' || SUPABASE_ANON_KEY === 'YOUR_SUPABASE_ANON_KEY') {
                grid.innerHTML = `
                    <div class="error">
                        <h3>Supabase Not Configured</h3>
                        <p>Edit this file and replace:</p>
                        <code>SUPABASE_URL</code> and <code>SUPABASE_ANON_KEY</code>
                        <p>with your Supabase project credentials.</p>
                        <p style="margin-top: 20px; color: #666;">
                            Get these from: Supabase Dashboard ‚Üí Settings ‚Üí API
                        </p>
                    </div>
                `;
                return;
            }

            try {
                // First, try to migrate any existing localStorage data
                await migrateFromLocalStorage();

                // Load companies from Supabase
                companyData = await loadCompanies();

                if (companyData.length === 0) {
                    grid.innerHTML = `
                        <div class="empty">
                            <h3>No companies in database</h3>
                            <p>Import your ashby-valid.csv file using the button above.</p>
                        </div>
                    `;
                    return;
                }

                generateGrid();

            } catch (error) {
                console.error('Init error:', error);
                grid.innerHTML = `
                    <div class="error">
                        <h3>Connection Error</h3>
                        <p>${error.message}</p>
                        <p style="margin-top: 10px; color: #666;">Check your Supabase credentials and try again.</p>
                    </div>
                `;
            }
        }

        // App is started by showApp() after successful login
    </script>
</body>
</html>
